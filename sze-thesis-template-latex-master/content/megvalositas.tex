\chapter{Megvalósítás}
\section{Alkalmazott módszerek}
A megvalósítás során az eddig megismert módszereket fogom felhasználni, azokat Python programozási nyelven fogom elkészíteni és ismertetni. Az egyes algoritmusokat függvények formájában készítem el, ezeket a függvényeket pedig több Python szkriptben is felhasználom.
\par Az eddig megismert módszerek közül elsősorban a nyers bemenetből emelem ki a játékterületet, ezt követően a golyók pozíciójának felismeréséhez kör detektálást és egy neurális hálózatot fogok használni. A neurális hálózat betanításához az adatkészletet kör detektálással, mintaillesztéssel és kézi válogatással fogom elkészíteni. A következőkben az egyes függvények működését, azokban felhasznált külső könyvtárak eszközeit ismertetem részleteiben.
\par A fejezetek felosztása az eddig megismert lépések szerint kerül rendezésre.

\section{A golyók pozíciója}

\subsection{A szükséges könyvtárak importálása}
Ahhoz hogy a függvények megfeleően működjenek, meg kell mondanunk a programnak, hogy használja a külső könyvtárakat.
\newline Ezt a következőképp tehetjük meg.

\vspace{2mm}\begin{lstlisting}[language=Python, numbers=left]
import math
import numpy as np
import cv2
\end{lstlisting}

\par A \lstinline{math} könyvtár segítségével matematikai műveleteket (gyökvonás, szinusz, koszinusz) tudunk végezni, a \lstinline{numpy} könyvtár a tömbök, mátrixok kezelését, azokkal való műveleteket segíti és gyorsítja, a \lstinline{cv2} pedig az OpenCV eszközeit teszi elérhetővé.

\subsection{Az asztal kivágása}
Annak érdekében, hogy a nyers képből kinyerjük a játékterületet, azt először be kell tölteni egy többdimenziós tömbbe. A kép betöltése többféleképp végbemehet, ezért ezt konkrétan nem részletezem.
\par A betöltött kép tömbjének alakja megegyezik a kép szélességével és magasságával, továbbá az intenzitási értékekkel, tehát ha betöltünk egy 1024 x 512 méretű RGB képet, annak tömbjének az első és második dimenziója 1024 és 512, a harmadik pedig az RGB (Piros, Zöld, Kék) intenzitásoknak megfelelően 3 méretű.
\par Fontos megjegyezni, hogy az OpenCV a képeket betöltéskor BGR formátumban tölti be, ez az elnevezésből adódóan annyiban tér el az RGB formátumtól, hogy a piros (R) és kék (B) színcsatornák fel vannak cserélve.
\par A nyers bemeneti kép megszerzése után készen állunk az asztal megkeresésére és kivágására. Első lépésként a képet átalakítjuk HSV formátumra, majd megadjuk az alsó és felső intenzitási értékhatárokat, amelyből elkészítjük a maszkot. Ezután maszkoljuk az eredeti képet a maszk segítségével.
\newline Ezt a következő kódsorokkal végezhetjük el.


\vspace{2mm}\begin{lstlisting}[language=Python, numbers=left]
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

lower_green = np.array([40, 190, 50])
upper_green = np.array([65, 255, 225])

mask = cv2.inRange(hsv, lower_green, upper_green)

result = cv2.bitwise_and(image, image, mask = mask)
\end{lstlisting}

\par A kódban az \lstinline{image} a bemeneti képünk, amelyet a \lstinline{cv2.cvtColor} függvénnyel \cite{cv2_cvt_color} konvertálunk át HSV formátumra. Ennek a függvénynek az első paramétere a bemeneti képünk, a második pedig a konverzió típusa, amely ebben az esetben BGR $\rightarrow$ HSV. A \lstinline{lower_green} és \lstinline{upper_green} változók az alsó és felső intenzitási határokat jelölik sorrendnek megfelelően. A maszk elkészítését a \lstinline{cv2.inRange} függvénnyel \cite{cv2_in_range} végezhetjük el itt a paraméterek sorban a HSV re konvertált képünk, valamint az alsó és felső intenzitás értékek.
\newline A függvény a következők alapján dönti el, a maszk intenzitását,

\begin{equation}
    M(I) = L(I) \le S(I) \le U(I)
    \label{for:maszkolas}
\end{equation}

\par ahol $M$ a maszk, $L$ az alsó, $U$ a felső és $S$ a bemeneti HSV képet jelöli. A \ref{for:maszkolas} függvény mindhárom intenzitásra alkalmazásra kerül, a maszkban az intervallumon belüli intenzitások 255, a kívüliek pedig 0 értéket kapnak. A maszk elkészítése után azt alkalmazzuk az eredeti bemenő képre a \lstinline{cv2.bitwise_and} függvény \cite{cv2_bitwise_and} segítségével. Itt a paraméterek a bejövő eredeti kép \lstinline{image} kétszer és a maszk \lstinline{mask}.
\newline A folyamat során a metódus a következőképp jár el,

\begin{equation}
    R(I) = S_1(I)\quad \land\quad S_2(I)\qquad ,ha\quad M(I) \ne 0
    \label{for:maszk_alkalmazas}
\end{equation}

\par ahol $R$ a kimenő maszkolt kép (\lstinline{result}) $S_1$ és $S_2$ a két bemeneti kép paraméter, és $M$ a maszk. A bemenetben a kép azért szerepel kétszer egymás után, mert a \ref{for:maszk_alkalmazas} függvényben láthatóan a két bemenő paraméter közt egy bit szintű 'és' művelet történik, amennyiben a maszk nem nulla. Ez azt teszi lehetővé, hogy az eredeti képet kapjuk a maszkolt elemek kivételével, ami azért történik, mert bit szinten ha két megegyező elem közt történik 'és' művelet, akkor az eredmény szintén megegyezik a két elemmel. Ennek a folyamatnak a kimenetele látható a már előzőleg tárgyalt \ref{fig:bemeneti_kep_mask} ábrán.
\par A maszkolt kép megszerzése után elvégezhetjük az éldetektálást, amelyet megelőz egy szürkeárnyalatolás.
\newline Ezeket a műveleteket a következő programsorokkal végezhetjük.

\vspace{2mm}\begin{lstlisting}[language=Python, numbers=left]
image_gray = cv2.cvtColor(result, cv2.COLOR_BGR2GRAY)

result = cv2.Canny(image_gray, 100, 200)
\end{lstlisting}

\par A szürkeárnyalati konverziót a már megismert \lstinline{cv2.cvtColor} függvénnyel \cite{cv2_cvt_color} végezzük el, majd ezután megkeressük az éleket a képen Canny éldetektálás \cite{cv2_canny,canny_edge_detection} (\lstinline{cv2.Canny}) segítségével.
\newline A Canny éldetektálás általában több lépésre bontható szét, ezek lehetnek:

\begin{itemize}
    \setlength\itemsep{-2pt}
    \item Homályosítás Gauss szűrővel \cite{shapiro2001} a zajcsökkentés érdekében
    \item Élek helyének és irányának megállapítása intenzitás-gradiensből
    \item Nem-Maximum vágás merőleges élek szűréshéhez
    \item Kettős küszöbölés élek szűréséhez
\end{itemize}

\par Az éldetektálásnál meg kell adnunk a függvénynek a szürkeárnyalatos képünket, továbbá két küszöbértéket, amelyet a Canny detektálás a kettős küszöbölés folyamat során fog felhasználni. Itt, ha a felső küszöb felett van egy potenciális él, azt felvesszük az élek közé, ha az alsó küszöb alatt van eldobjuk és ha a felső és alsó küszöbök közt helyezkedik el, akkor a szomszédos pixelek alapján vesszük fel élnek. Az éldetektálással kapott kép a \ref{fig:bemeneti_kep_edge} ábrán látható.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=150mm, keepaspectratio]{figures/input_screen_edge.png}
    \caption{A Canny éldetektálás után kapott kép.}
    \label{fig:bemeneti_kep_edge}
\end{figure}